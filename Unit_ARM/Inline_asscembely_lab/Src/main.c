/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
//A simple program that switches the cpu access level
#include "STM32F103X6.h"
#include "STM32_F103C6_EXTI_driver.h"
#include "STM32_F103C6_gpio_driver.h"
#include "STM32_F103C6_RCC_driver.h"
#include "STM32_F103C6_USART_driver.h"
#include "STM32_F103C6_SPI_driver.h"
uint8_t IRQ_Flag = 0;

int control_register = 0 , ipsr_register = 0;


enum cpuaccesslevel{
	piviledged,
	unpiviledged
};
void cpu_switch_access_level(enum cpuaccesslevel level){
	switch(level)
	{
	case piviledged:
		//Clear bit 0 of control register
		__asm("mrs r3, CONTROL \n\t"
			  "lsr r3,r3,#0x1 \n\t"
			  "lsl r3,r3,#0x1 \n\t"
			  "msr CONTROL,r3 ");
		break;
	case unpiviledged:
		//set bit 0 of control register
		__asm("mrs r3, CONTROL \n\t"
			  "orr r3,r3,#0x1 \n\t"
			  "msr CONTROL,r3 ");
		break;
	}

}
void EXTI9_CALLBACK(void)
{
	IRQ_Flag = 1;
	__asm("MRS %[ipsr],IPSR"
			:[ipsr] "=r" (ipsr_register));
	cpu_switch_access_level(piviledged);
}
int val1 = 1,val2=2,val3=0;

int main(void)
{
	RCC_GPIOB_CLK_EN();
	RCC_AFIO_CLK_EN();

	//Set EXTI Configuration
	EXTI_PINCONFIG_t EXTIConfig;
	EXTIConfig.EXTI_PIN = EXTI9PB9;
	EXTIConfig.Trigger = EXTI_Trigger_RISING;
	EXTIConfig.IRQ_CallBack = EXTI9_CALLBACK;
	EXTIConfig.IRQ_EN = IRQ_Enable;
	EXTI_Init(&EXTIConfig);



	IRQ_Flag = 1;
	__asm("nop \n\t nop \n\t nop");
	//	//mov val,#0xff --> Output parameter in inline asm
	//	__asm("mov %0,#0xff"
	//			:	"=r"	(val)	);
	//
	//	__asm("nop \n\t nop \n\t nop");
	//	//mov r0 ,val --> Output parameter in inline asm
	//	__asm("mov r0, %0"
	//			:
	//			:"r" (val)  );
	//	__asm("add %0 , %1 ,%2 "
	//		  :"=r" (val3)
	//		  :"r"(val1),"r"(val2)
	//		   );
	__asm(" MRS %[CR] , CONTROL"
			:[CR] "=r" (control_register));

	cpu_switch_access_level(unpiviledged);
	cpu_switch_access_level(piviledged);
	while (1)
	{
		if(IRQ_Flag)
		{
			IRQ_Flag = 0;
		}
		else { /* Misra */ }
	}


}
